\subsection{Notes on warping in sample}

<<setup, include=F>>=
library(baseline)
library(grDevices)
library(ggjoy)
library(nloptr)
library(rawTof)

source('R/tofReader.R')
source('R/tofSparse.R')

#tof.h5 <- 'testdata/2017.02.15-15h22m12s D6-EtOHbreathclemens.h5'
tofA.h5 <- 'testdata/2017.06.20-15h04m22s Aurelio valve off.h5'
tofA <- tofH5(tofA.h5)
sumSpecA <- (sumSpec.TofH5(tofA))/tofA$indexhelp$N
ntest <- 7
scan_indices <- floor(seq(from=1, to=tofA$indexhelp$N, length.out=ntest))
specs <- lapply(scan_indices, function(i) readInd.TofH5(tofA,i))
mcfun <- recMassCal.TofH5(tofA)

dt0 <- data.table(do.call(cbind, specs))
colnames(dt0) <- paste(round((scan_indices-1)/5), 's')
dt0[, pos:=seq_along(`0 s`)]
dt0[, mass:=mcfun$toMass(pos)]
dt1 <- melt(dt0,c('pos','mass'))

ref <- data.table(value=sumSpecA, 
				  pos = seq_along(sumSpecA), variable="Sum Spec")
ref[, mass:=mcfun$toMass(pos)]

plotComp <- function(refspec, otherspec = NULL, from, to, 
					 ylim=c(0,1e2), ylab='signal'){
  plot(refspec, type='l', 
	   xlim=c(from, to),
	   ylim=ylim,
	   xlab='index',
	   ylab=ylab
	   )
  if (!is.null(otherspec)) lines(otherspec, type='l', col='red')
  massRange <- pretty(with(mcfun, c( toMass(from), toMass(to))),n=10)
  indRange <- with(mcfun, toIndex(massRange))
  bad <- indRange < from | indRange > to
  massRange <- massRange[!bad]
  indRange <- indRange[!bad]
  axis(3,indRange, labels=massRange,line=1,col="red",col.ticks="red",col.axis="red")
}


prep_spec <- function(sspec, wid=30){
  workspec <- baseline(matrix(sspec, nrow=1), method= 'rollingBall', wm=100, ws=100)@corrected[1,]
  workspec[workspec<0.001]<- 0
  zapsmall(log1p(workspec), digits=2)
}

inner_reference <- local({
  ss_spec <- ksmooth(seq_along(sumSpecA), sumSpecA, 'normal', bandwidth=16)$y
  prep_spec(ss_spec)
})

@

The situation inside a single measurement file is different.  First
individual scans are much noisier and have >90 \% zero signal.  Second
there are up to some thousand spectra to align with each other.  On the
other hand it is plausible that from one spectrum to the next the shift
should be small.  Figures \ref{fig:plotoverw45} and
\ref{fig:plotoverw34} shows a sum spectrum together with seven equally
spaced spectra along the measurement that compromise it.  Although the
individual scans are noisy it is noticable that the center of the first
spectrum is to the left of the sum spectrum while the later are not so
clear right of the sum spectrum.  For the \si{300}{s} and \si{900}{s}
spectrum finding the peak is not pronounced so aligning them with their
maximum is error prone.  The shifts seem small -- visually maybe 1/30
amu at maximum.  However the peaks are  notable wider than the peak in
sum spectrum.  Considering the \ac{FWHM} it seems that the sum spec has
about half the width of individual specs.  Approximatel we are looking
in the sum spec at \ac{FWHM} resolution of 1/10000 where for individual
peaks it's aroung 3/10000.  The correction for drift is also around
1/10000.

The sum spectrum makes a natural reference to which the individual
spectra should be aligned.  Although it may be useful to recalculate the
sum spectrum after alignment.


<<plotoverw45, fig.cap="Spectrum of a peak at m/z 45 in sum spectrum as well as in seven individual scans.  A slight drift to the right is noticable">>= 
from=12.1969e4
to=12.2005e4
ggplot(rbind(ref,dt1) %>% filter(pos>from & pos<to), 
	   aes(x=mass, y=variable, height=value)) + 
  geom_joy(stat='identity', alpha=0.3) + theme_joy()  + 
  theme(legend.position = "none", 
  		axis.text = element_text(size = 8, colour="black")) 


@

<<plotoverw34, fig.cap="Spectrum of peak at m/z 34 in sum spectrum as well as in seven individual scans.  A slight drift to the right is noticable">>= 
from=10.6435e4
to=10.6465e4
ggplot(rbind(ref,dt1) %>% filter(pos>from & pos<to), 
	   aes(x=mass, y=variable, height=value)) + 
  geom_joy(stat='identity', alpha=0.3) + theme_joy()  + 
  theme(legend.position = "none", 
  		axis.text = element_text(size = 8, colour="black")) 
@

<<searchFunctions, include=F>>=
optim_generator <- function(reference_spec, generated_w, warp_fun){
  reference <- reference_spec/sqrt(sum(reference_spec^2))
  function(a){
	warped <- generated_w(warp_fun(a), 
						  where=seq_along(reference))
	nw <- sqrt(sum(warped^2))
	-sum(reference * warped)/nw
  }
}

warp0 <- function(a) function(x) a[[1]]+x

warp1 <- function(a) function(x) a[[1]]+ a[[2]]*x

@


A number of spectra is analysed for the optimal shift and it seems the
optimum is close to the unshifted spectrum inside the measurement.

<<shiftfun, include=F>>=
matches <- function(i,sh_pos){
  ss <- readInd.TofH5(tofA,i)
  ss_spec <- ksmooth(seq_along(ss), ss, 'normal', bandwidth=8)$y
  generated_w <- fast_warp0(log1p(ss_spec))
  og <- optim_generator(inner_reference, generated_w, warp0)
  sh_data <- sapply(sh_pos, Vectorize(og))
  data.frame(ind=i/5, x=sh_pos, mv=-sh_data)
}
@

<<shiftmatch, cache=T, fig.cap="Maximum of shift along the measurement.">>=
local({
sh_pos <- seq(-3500, 3500,length.out= 121)
md <- lapply(scan_indices, function(i) matches(i,sh_pos))
md2 <- do.call(rbind, md)
md2$ind <- as.factor(md2$ind)

ggplot(md2, aes(x=x, y=ind, height=mv)) + 
  geom_joy(stat='identity', alpha=0.3) + theme_joy()  + 
  theme(legend.position = "none", 
  		axis.text = element_text(size = 8, colour="black")) 
})
#plot(sh_pos, -sh_data, type='l')
@

<<shiftmatchlocal, cache=T, fig.cap="local of shift along the measurement.">>=
local({
sh_pos <- seq(-150, 150,length.out= 31)
md <- lapply(scan_indices, function(i) matches(i,sh_pos))
md2 <- do.call(rbind, md)
md2$ind <- as.factor(md2$ind)
md2$mv <- md2$mv - min(md2$mv)

ggplot(md2, aes(x=x, y=ind, height=mv)) + 
  geom_joy(stat='identity', alpha=0.3) + theme_joy()  + 
  theme(legend.position = "none", 
  		axis.text = element_text(size = 8, colour="black")) 
})
#plot(sh_pos, -sh_data, type='l')
@

<<searchFits, include=F, eval=T, dependson='searchFunctions', cache=T>>=
warp_search2 <- function(ref,new_spec){
  ss_spec <- ksmooth(seq_along(new_spec), new_spec, 'normal', bandwidth=16)$y
  generated_w <- make_densewarp(log1p(new_spec))
  og_fin <- optim_generator(ref, generated_w, warp1)

  # Note author advises against using ftol or xtol for global
  res2 <- nloptr(x0=c(0,1), eval_f=og_fin, lb=c(-100,0.9), ub=c(100,1.1),
  				opts = list("algorithm" = "NLOPT_LN_NELDERMEAD", 
  							  "ftol_abs" = 1e-4,
  							  "maxeval" = 200))
  with(res2, c(objective, solution))
}
n_calibs <- 50
cal_indices <- unique(floor(seq(from=1, to=tofA$indexhelp$N, length.out=n_calibs)))
wfs <- lapply(cal_indices, function(i) warp_search2(inner_reference, readInd.TofH5(tofA,i)))
@

<<plotfits, fig.cap="Local warp parameter.", dependson="searchFits">>=
par(mfrow=c(1,2)) 
ti <- cal_indices/5
plot(x = ti, y=sapply(wfs, function(x) x[[2]]),
	 xlab='time', ylab="shift")
plot(x = ti, y=sapply(wfs, function(x) x[[3]]),
	 xlab='time', ylab="slope")
@

In figure \ref{fig:plotfits} we see a how the warp parameter change during the measurement.
The slope does not seem significantly different from \num{1.0}.  There doesn't apper to be a structure.  So maybe even just a plain shift will be enough.

<<, include = F, eval=F>>=
new_spec <- (specs[[2]])
ss_spec <- ksmooth(seq_along(new_spec), new_spec, 'normal', bandwidth=16)$y
ss_log1 <- log1p(ss_spec)

plot(sumSpecA, type='l', xlim=c(8e4,8.2e4), ylim=c(0,300))
lines(ss_spec, col='red')

plot(inner_reference, type='l', xlim=c(8e4,8.2e4))
lines(ss_log1, col='red')


  generated_w <- fast_warp0(log1p(new_spec))
at0 <- new_spec(
plot(inner_reference, type='l', xlim=c(8e4,8.2e4))
lines(new_spec, col='red')

@

<<searchFit1, include=F, eval=T, dependson='searchFunctions', cache=T>>=
warp_search1 <- function(ref,new){
  generated_w <- fast_warp0(log1p(new))
  og_fin <- optim_generator(ref, generated_w, warp0)

  # Note author advises against using ftol or xtol for global!
  res2 <- nloptr(x0=c(0), eval_f=og_fin, lb=c(-100), ub=c(100),
  				opts = list("algorithm" = "NLOPT_LN_NELDERMEAD", 
  							  "ftol_abs" = 1e-4,
  							  "maxeval" = 200))
  with(res2, c(objective, solution))
}
n_calibs <- 50
cal_indices <- unique(floor(seq(from=1, to=tofA$indexhelp$N, length.out=n_calibs)))
wfs1 <- lapply(cal_indices, function(i) warp_search1(inner_reference, readInd.TofH5(tofA,i)))
@

<<plotfit1, fig.cap="Local warp parameter just shift.", dependson="searchFits">>=
ti <- cal_indices/5
plot(x = ti, y=sapply(wfs1, function(x) x[[2]]),
	 xlab='time', ylab="shift")
@

Even applying all these techniques the warp seems to depend on the
measurement setup.  Meaning the moments when the volunteer was connected
to the \ac{TOF-MS} coincides with a change in warp.  A good indicator is
to trace m/z 59 as shown in figure \ref{fig:plot59}.  Maybe this has to
do with the significantly increased humidity.

<<plot59, fig.cap="Trace of preintegrated peak at m/z 59, smoothed over a \\si{16}{s} window.", cache = T>>=
local({
  tmp <- H5Gopen(tofA$fid, "PeakData")
  pt <- H5Dread(H5Dopen(tofA$fid, "PeakData/PeakTable"))
  loc <- which(pt$mass == 59)

  pl <- H5Dread(H5Dopen(tofA$fid, "PeakData/PeakData"))
  pm <- matrix(pl, nrow=dim(pl)[[1]])
  pint <- pm[loc,]
  ptime <- seq_along(pint)/5
ss_pint <- ksmooth(ptime, pint, 'normal', bandwidth=16)$y
  plot(x=ptime, y=ss_pint, type='l', xlab='time [s]', ylab = 'signal 59')
})
@
