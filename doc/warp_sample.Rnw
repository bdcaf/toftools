\subsection{Notes on warping between samples}

<<setup, include=F>>=
library("DEoptim")
library(baseline)
library(zoo)
library(grDevices)

source('R/tofReader.R')
source('R/tofSparse.R')

#tof.h5 <- 'testdata/2017.02.15-15h22m12s D6-EtOHbreathclemens.h5'
tofA.h5 <- 'testdata/2017.06.22-11h13m23s ca valve open.h5'
tofB.h5 <- 'testdata/2017.06.20-15h04m22s Aurelio valve off.h5'
tofA <- tofH5(tofA.h5)
tofB <- tofH5(tofB.h5)
sumSpecA <- (sumSpec.TofH5(tofA))/tofA$indexhelp$N
sumSpecB <- (sumSpec.TofH5(tofB))/tofB$indexhelp$N

mcfun <- recMassCal.TofH5(tofA)


plotComp <- function(refspec, otherspec = NULL, from, to, 
					 ylim=c(0,1e2), ylab='signal'){
  plot(refspec, type='l', 
	   xlim=c(from, to),
	   ylim=ylim,
	   xlab='index',
	   ylab=ylab
	   )
  if (!is.null(otherspec)) lines(otherspec, type='l', col='red')
  massRange <- pretty(with(mcfun, c( toMass(from), toMass(to))),n=10)
  indRange <- with(mcfun, toIndex(massRange))
  bad <- indRange < from | indRange > to
  massRange <- massRange[!bad]
  indRange <- indRange[!bad]
  axis(3,indRange, labels=massRange,line=1,col="red",col.ticks="red",col.axis="red")
}

@

Immediate results hinted that in single measurements the drift is small.
To formulate the procedure warping between measurements was chosen.
Concretely the samples \texttt{\Sexpr{tofA.h5}} and
\texttt{\Sexpr{tofB.h5}} are selected and the sum spectra will be
examined.  A subsection of the spectra are shown in figure \ref{fig:wssumspec}.

Sum spectra are different to the spectra of individual scans in the
sense that even in the range between molecular masses noise adds up to a
smooth signal.  To keep alignment simple the baseline is cleaned useing
the baseline package from \citet{Lil2015}.  A regional plot is shown in
figure \ref{fig:wsbaseline}.  Most algorithm in this package work
sufficiently well.  Although the default \texttt{als} algorithm requires
construction of a matrix with dimension of lenght sample $\times$ lenght
sampl, which fails due to memory constraints as these spectra are
typical \num{400000} entries.

<<wssumspec, cache=T,fig.cap='Comparing the unprocessed sum spectra of two samples, the shift corresponds to about 0.5 amu at m/z 60'>>=
plotComp(sumSpecA, sumSpecB, from=11.5e4, to=13.5e4)
@

<<wsbaseline, fig.cap='baseline correction in sum spectrum.', cache=T>>=
sspec <- sumSpecA
refSpec <- baseline(matrix(sspec, nrow=1), 
					method= 'rollingBall', 
					wm=100, ws=100)@corrected[1,]
refSpec[refSpec<0.005]<-0

plotComp(sumSpecA, refSpec, from=12.0e4, to=13.0e4, ylim=c(0,2))
@

<<wssat, cache=T, depends=c('wsbaseline'), fig.cap='saturated peaks'>>=
par(mfrow=c(1,2)) 
plotComp(refSpec, from=7.99e4, to=8.02e4)
plotComp(refSpec, from=9.96e4, to=9.98e4)
@

<<,include = F>>=
prep_spec <- function(sspec, atof, wid=30){
  workspec <- baseline(matrix(sspec, nrow=1), method= 'rollingBall', wm=100, ws=100)@corrected[1,]
  workspec[workspec<0.001]<- 0
  log1p(workspec)
}
@

The aim is to find a warp that will adjust the position of peaks in the
sample spectrum to the one in the reference spectrum.  This often is
done by means of mass calibration.  Although in order for this to work
peaks of known mass need to be identified in the spectrum.  It is
generally not easy to find a sufficient number of peaks whose mass is
known and are present in sufficient quality.  Usually this is a manual
identification task which makes it hard to automate.  Typically these peaks are
directly related to precursor ions and of low mass - generally it is
hard to identify peaks at high masses.  In presented workflow we don't
identify peaks, but instead search for a warp that transforms the
spectrum best.

Some warp functions are available.  As TOF spectrometry has
a simple structure we find the parametric time warp most promising.  The
most common dynamic time warp is unsuitable, as we can not guarantee all
peaks to be present in each spectrum.
The resampling algorithm presented in \citet{Eilers2004a} is not
suitable for our approach as we need AUC of peaks maintained over the
transformation.  The problem is that presented algorithm only works
well if within every original bin there is a single new coordinate.
However starting with linear transformations this is no longer
guaranteed.  Fortunately there is a simple correction by instead
interpolating the cumulative sum and calculating differences over the
new values.

It is worth stressing that even if the parametric function describing
the reindexing is simple and differentiable the warping function is not.

The spectra are also dominated by large peaks.  In order to reduce their
influence the signal is \texttt{log1p} transformed.  An exemplary
presentation is shown in figure \ref{fig:wscleansum}.

<<wscleansum, cache=T, fig.cap='peak log1p profile of two measurements'>>=
ssa <- prep_spec(sumSpecA)
ssb <- prep_spec(sumSpecB)
plotComp(ssa, ssb, from=12.0e4, to=13.0e4, ylim=c(0,4), ylab='log1p signal')
@

<<, include=F>>=
optim_generator <- function(orientSpec, wf){
  reference <- orientSpec/sqrt(sum(orientSpec^2))
  function(a, dense_spec){
	warp_fun <- wf(a)
	warped <- warp_dense( dense_spec, warp_fun)
	cor.full.full(warped, reference) 
  }
}

warp0 <- function(a) 
  function(x) a[[1]]+x # + a[[2]]*x # + a[[3]]*x^2

warp1 <- function(a) 
  function(x) a[[1]]+ a[[2]]*x # + a[[2]]*x # + a[[3]]*x^2

@

An exemplary warping based on shifting the spectrum is shown in figure
\ref{fig:wsshiftplot}.  There is an optimal warping shifting the
spectrum around 500 indices to the left.  But it is also visible there
are locale maxima shifting spectra to other full masses.  This makes
finding the globaly best warping demanding.

<<wscalcshifts,include=F, cache=T>>=
og <- optim_generator(ssa, warp0)
og2 <- function(...) -og(...)
#og(1,ssb)
shifts <- seq(from=-3000, to=2000, length.out=99)
val <- sapply(shifts, function(x) og(x,ssb))

est.shi <- DEoptim(og2, 
				   lower=-3000,
				   upper = 3000,
				   dense_spec=ssb,
				   control=list(VTR=-0.5)
				   )

bestbest <- optim(est.shi$optim$bestmem, 
				  og2, 
				  gr=NULL, 
				  ssb,
				  lower=-3000, 
				  upper=3000,
				  method='Brent')
@

<<wsshiftplot, cache=T, fig.cap="distance to reference measurement on shifted spectrum", dependson="wscalcshifts">>=
plot(shifts,val, type='l', xlab='shift', ylab='agreement')
abline(v=bestbest$par)
text(x=bestbest$par, y=0.1, sprintf("%3.1f",bestbest$par), pos=4)
@

<<>>=
og <- optim_generator(ssa, warp1)
og2 <- function(...) -og(...)
wif <- Vectorize(function(a,b) og(c(a,b),ssb))
#og(1,ssb)
@

<<wshift_opt2, cache=T, include=F>>=
est.shi <- DEoptim(og2, 
				   lower=c(-1000, 0.95),
				   upper = c(1000, 1.05),
				   dense_spec=ssb,
				   control=list(VTR=-0.5)
				   )

bestbest <- optim(est.shi$optim$bestmem, 
				  og2, 
				  gr=NULL, 
				  ssb)
@

<<wscalcshift2,include=F, dependson="wshift_opt2", cache=T>>=
xs <- sort(c(bestbest$par[[1]],seq(from=-800, to=-200, length.out=31)))
ys <- sort(c(bestbest$par[[2]],seq(from=0.98, to=1.02, length.out=31)))
vals <- outer(xs, ys, FUN=wif )
@

<<wscalcshift2local,include=F, cache=T>>=
xs_local <- sort(c(bestbest$par[[1]],seq(from=-700, to=-300, length.out=31)))
ys_local <- sort(c(bestbest$par[[2]],seq(from=0.995, to=1.005, length.out=31)))
vals_local <- outer(xs_local, ys_local, FUN=wif )
@
<<wscalcshift2locallocal,include=F, cache=T>>=
xs_local2<- sort(c(bestbest$par[[1]],seq(from=-550, to=-450, length.out=31)))
ys_local2<- sort(c(bestbest$par[[2]],seq(from=0.999, to=1.001, length.out=31)))
vals_local2 <- outer(xs_local2, ys_local2, FUN=wif )
@

In figure \ref{fig:wsshiftplot2} the two dimensional case is shown.  It
seems similar looking peaks form a lines.  If we zoom into the region
around the maximum in figure \ref{fig:wsshiftplot2local} and
\ref{fig:wsshiftplot2locallocal} we see that the peaks along these lines
actually form a connected smooth \textit{ridge} and the apparent
separation is just an artifact from aliasing at peculiar points.  Still
finding the maximum is sensitive to the start location.  Only particular
optimization algorithm deal with such a situation sufficiently.  Here a
genetic algorithm is applied.  Ultimately this search is done in two
steps.  First using a genetic algorithm to locate a correlation > 0.5
and in a second step conjugate gradient optimization to locate the
maximum.  This is faster than using the genetic algorithm
exclusively as it only slowly converges to the maximum. 

Although there may be a second approach.  Since the \textit{ridges} seem
to stretch next to each other it should be possible to identify the
correct one in one dimensional genetic search and in a second step do
the high dimensional search for the maximum using conjugate gradient
search.

<<wsshiftplot2, cache=T, dependson=c("wscalcshift2",'wshift_opt2'),fig.cap="distance matrix to reference measurement on shifted and compressed spectrum", dependson="wscalcshift2">>=
par(mar=c(1,0,0,0))
pm <- persp(x=xs,y=ys,z=vals, 
			xlab='shift', 
			ylab='scale',
			zlab='agreement', 
			phi=30,
			theta=30, 
			d=2,
			xaxs="i",
			yaxs="i",
			ticktype="detailed"
			)
with(bestbest, {
	   nc <- trans3d(x=par[[1]], y=par[[2]], z=-value, pm)
	   points(nc, col='red')
	   text(x=nc$x, y=nc$y, sprintf("cor %1.2f\n(%3.1f, %1.5f)",
									-value, par[[1]], par[[2]]-1), 
	   		pos=4, col='red') 
			})
@

<<wsshiftplot2local, cache=T, dependson=c("wscalcshift2local",'wshift_opt2'),fig.cap="local distance matrix to reference measurement on shifted and compressed spectrum", dependson="wscalcshift2">>=
par(mar=c(1,0,0,0))
pm <- persp(x=xs_local,y=ys_local,z=vals_local, 
			xlab='shift', 
			ylab='scale',
			zlab='agreement', 
			phi=30,
			theta=30, 
			d=2,
			xaxs="i",
			yaxs="i",
			ticktype="detailed"
			)
with(bestbest, {
	   nc <- trans3d(x=par[[1]], y=par[[2]], z=-value, pm)
	   points(nc, col='red')
	   text(x=nc$x, y=nc$y, sprintf("cor %1.2f\n(%3.1f, %1.5f)",
									-value, par[[1]], par[[2]]-1), 
	   		pos=4, col='red') 
			})
@
<<wsshiftplot2locallocal, cache=T, dependson=c("wscalcshift2locallocal",'wshift_opt2'),fig.cap="direct environment around maximum of distance matrix to reference measurement on shifted and compressed spectrum", dependson="wscalcshift2">>=
par(mar=c(1,0,0,0))
pm <- persp(x=xs_local2,y=ys_local2,z=vals_local2, 
			xlab='shift', 
			ylab='scale',
			zlab='agreement', 
			phi=30,
			theta=30, 
			d=2,
			xaxs="i",
			yaxs="i",
			ticktype="detailed"
			)
with(bestbest, {
	   nc <- trans3d(x=par[[1]], y=par[[2]], z=-value, pm)
	   points(nc, col='red')
	   text(x=nc$x, y=nc$y, sprintf("cor %1.2f\n(%3.1f, %1.5f)",
									-value, par[[1]], par[[2]]-1), 
	   		pos=4, col='red') 
			})
@



