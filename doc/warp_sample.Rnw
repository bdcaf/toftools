\subsection{Notes on warping between samples}

<<setup, includ = >>=
library("baseline")
library("grDevices")
library("nloptr")

source("R/tofReader.R")
source("R/tofSparse.R")

tof_a.h5 <- "testdata/2017.06.22-11h13m23s ca valve open.h5"
tof_b.h5 <- "testdata/2017.06.20-15h04m22s Aurelio valve off.h5"
tof_a <- tof_h5(tof_a.h5)
tof_b <- tof_h5(tof_b.h5)
sum_spec_a <- (sum_spec.tof_h5(tof_a))/tof_a$indexhelp$N
sum_spec_b <- (sum_spec.tof_h5(tof_b))/tof_b$indexhelp$N

mcfun <- stored_mass_cal.tof_h5(tof_a)

optim_generator <- function(reference_spec, generated_w, warp_fun){
  reference <- reference_spec/sqrt(sum(reference_spec^2))
  function(a){
    warped <- generated_w(warp_fun(a),
                          wher = eq_along(reference))
    nw <- sqrt(sum(warped^2))
    -sum(reference * warped)/nw
  }
}

plot_comp <- function(refspec, otherspec = NULL, from, to,
                      yli = c(0, 1e2), yla = signal"){
  plot(refspec, typ = l",
       xli = (from, to),
       yli = lim,
       xla = index",
       yla = lab
       )
  if (!is.null(otherspec)) lines(otherspec, typ = l", co = red")
  mass_range <- pretty(with(mcfun, c( to_mass(from), to_mass(to))),
                       = 0)
  index_range <- with(mcfun, to_index(mass_range))
  bad <- index_range < from | index_range > to
  mass_range <- mass_range[!bad]
  index_range <- index_range[!bad]
  axis(3, index_range, label = ass_range, lin = ,
       co = red", col.tick = red", col.axi = red")
}

@

Immediate results hinted that in single measurements the drift is small.
To formulate the procedure warping between measurements was chosen.
Concretely the samples \texttt{\Sexpr{tof_a.h5}} and
\texttt{\Sexpr{tof_b.h5}} are selected and the sum spectra will be
examined.  A subsection of the spectra are shown in \fref{fig:wssumspec}.

Sum spectra are different to the spectra of individual scans in the
sense that even in the range between molecular masses noise adds up to a
smooth signal.  To keep alignment simple the baseline is cleaned using
the baseline package from \citet{Lil2015}.  A regional plot is shown in
\fref{fig:wsbaseline}.  Most algorithm in this package work
sufficiently well.  Although the default \texttt{als} algorithm requires
construction of a matrix with dimension of length sample $\times$ length
sample, which fails due to memory constraints as these spectra are
typical \num{4e5} entries.

<<wssumspec, cach = , fig.ca = Comparing the unprocessed sum spectra of two samples, the shift corresponds to about 0.5 amu at m/z 60'>>=
plot_comp(sum_spec_a, sum_spec_b, fro = 1.5e4, t = 3.5e4)
@


The aim is to find a warp that will adjust the position of peaks in the
sample spectrum to the one in the reference spectrum.  This often is
done by means of mass calibration.  Although in order for this to work
peaks of known mass need to be identified in the spectrum.  It is
generally not easy to find a sufficient number of peaks whose mass is
known and are present in sufficient quality.  Usually this is a manual
identification task which makes it hard to automate.  Typically these peaks are
directly related to precursor ions and of low mass - generally it is
hard to identify peaks at high masses.  In presented work flow we don't
identify peaks, but instead search for a warp that transforms the
spectrum best.

Some warp functions are available.  As \ac{TOF} spectrometry has
a simple structure we find the parametric time warp most promising.  The
most common dynamic time warp is unsuitable, as we can not guarantee all
peaks to be present in each spectrum.
The resampling algorithm presented in \citet{Eilers2004a} is not
suitable for our approach as we need \ac{AUC} of peaks maintained over the
transformation.  The problem is that presented algorithm only works
well if within every original bin there is a single new coordinate.
However starting with linear transformations this is no longer
guaranteed.  Fortunately there is a simple correction by instead
interpolating the cumulative sum and calculating differences over the
new values.

It is worth stressing that even if the parametric function describing
the reindexing is simple and differentiable the warping function is not.

The spectra are also dominated by large peaks.  In order to reduce their
influence the signal is \texttt{log1p} transformed.  An exemplary
presentation is shown in \fref{fig:wscleansum}.

<<wsbaseline, fig.ca = baseline correction in sum spectrum.', cach = >>=
reference_spectrum <- matrix(sum_spec_a, nro = ) %>%
  baseline(spectra = ., method= "rollingBall",
           w = 00, w = 00) %>%
  slot("corrected") %>% t %>%
  pmax(0)

plot_comp(sum_spec_a, reference_spectrum, fro = 2.0e4, t = 3.0e4,
          yli = (0, 2))
@

<<wssat, cach = , depend = ("wsbaseline"), fig.ca = saturated peaks">>=
par(mfro = (1, 2))
plot_comp(reference_spectrum, fro = .99e4, t = .02e4)
plot_comp(reference_spectrum, fro = .96e4, t = .98e4)
@

<<prep_function, include = F>>=
prep_spec <- function(sspec, wi = 0, w = 00, w = 00)
  matrix(sspec, nro = ) %>%
    baseline(spectra = ., method= "rollingBall", w = m, w = s) %>%
    slot("corrected") %>% t %>%
    pmax(0) %>%
    log1p %>%
    zapsmall(digit = ) %>%
    ksmooth(seq_along(.), ., kerne = normal", bandwidt = 6) %>%
    `[[`("y")
@

<<calc_preps, includ = , cach = >>=
ssa <- prep_spec(sum_spec_a)
ssb <- prep_spec(sum_spec_b)
@

<<wscleansum, cach = , fig.ca = peak log1p profile of two measurements'>>=
plot_comp(ssa, ssb, fro = 2.0e4, t = 3.0e4,
          yli = (0, 4), yla = log1p signal")
@


An exemplary warping based on shifting the spectrum is shown in
\fref{fig:wsshiftplot}.  There is an optimal warping shifting the
spectrum around 500 indices to the left.  But it is also visible there
are locale maxima shifting spectra to other full masses.  This makes
finding the globally best warping demanding.  Comparing with
\fref{fig:wscleansum} we see that in this mass range there are around
\num{1500} indices corresponding one amu step.  The neighbouring maxima
therefore correspond shifting the peak comb by about one amu.  As the
peaks are not regularly spaced in time axis these secondary peaks have
much poorer match.

<<, includ = >>=
warp0 <- function(a)
  function(x) a[[1]]+x

warp1 <- function(a)
  function(x) a[[1]]+ a[[2]]*x
og <- local({
  generated_w <- make_densewarp(ssb)
  optim_generator(ssa, generated_w, warp0)
})
@

<<wscalcshifts, includ = , cach = >>=
shifts <- seq(fro = 6000, t = 000, length.ou = 9)
val <- sapply(shifts, og)
@

<<wscalcoptshift, includ = , cach = >>=
best_shift <- local({
  first_shift <- nloptr( x0 = 0,
                        eval_f = og,
                        lb =-3000,
                        ub = 3000,
                        opts = list(algorith = NLOPT_GN_DIRECT_L",
                                    maxeval = 100)
                        )

  nloptr( x0 = first_shift$solution,
         eval_f = og,
         l = 3000,
         ub = 3000,
         opts = list(algorith = NLOPT_LN_BOBYQA", xtol_ab = .01)
         )
})
@

<<wsshiftplot, cach = , fig.ca = distance to reference measurement on shifted spectrum", dependso = wscalcshifts">>=
plot(shifts, -val, typ = l", xla = shift", yla = agreement")
abline( = est_shift$solution, lt = )
text( = est_shift$solution,  = .5,
     sprintf("%3.1f", best_shift$solution), po = )
@


<<wshift_opt2, cach = , includ = >>=
og1 <- optim_generator(ssa, make_densewarp(ssb), warp1)
wif1 <- Vectorize(function(a, b) og1(c(a, b)))

best_shift <- local({
  first_shift <- nloptr( x0 = c(0, 1),
                        eval_f = og1,
                        lb = c(-1000, 0.95),
                        ub = c(1000, 1.05),
                        opts = list(algorith = NLOPT_GN_DIRECT_L",
                                    maxeval = 100)
                        )
  nloptr( x0 = first_shift$solution,
         eval_f = og1,
         lb = c(-1000, 0.95),
         ub = c(1000, 1.05),
         opts = list(algorith = NLOPT_LN_BOBYQA",
                     xtol_ab = (0.001, 1e-9))
         )
})

make_match_surf <- function(xs, ys) {
  xsc <- sort(unique(c(best_shift$solution[[1]], xs)))
  ysc <- sort(unique(c(best_shift$solution[[2]], ys)))
  vals <- outer(xsc, ysc, FU = if1 )
  list(x = sc, y = sc, val = als)
}

@


<<plotfunc, cach = , includ = >>=
plot_match <- function(match_surf) {
  with(match_surf, {
         par(ma = (1, 0, 0, 0))
         pm <- persp( = s,  = s,  = vals,
                     xla = shift",
                     yla = scale",
                     zla = agreement",
                     ph = 0,
                     thet = 0,
                     = ,
                     xax = i",
                     yax = i",
                     ticktyp = detailed"
                     )
         with(best_shift, {
                nc <- trans3d( = olution[[1]],  = olution[[2]],  = objective, pm)
                points(nc, co = red")
                       text( = c$x,  = c$y, sprintf("cor %1.2f\n(%3.1f, %1.5f)",
                                                    -objective, solution[[1]], solution[[2]]-1),
                            po = , co = red")
                     })
})
}
@


In \fref{fig:wsshiftplot2} the two dimensional case is shown.  It
seems similar looking peaks form a lines.  If we zoom into the region
around the maximum in \fref{fig:wsshiftplot2local} and
\fref{fig:wsshiftplot2locallocal} we see that the peaks along these lines
actually form a connected smooth \textit{ridge} and the apparent
separation is just an artifact from aliasing at peculiar points.  Still
finding the maximum is sensitive to the start location.  Only particular
optimization algorithm deal with such a situation sufficiently.  Here a
genetic algorithm is applied.  Ultimately this search is done in two
steps.  First using a genetic algorithm to locate a correlation > 0.5
and in a second step conjugate gradient optimization to locate the
maximum.  This is faster than using the genetic algorithm
exclusively as it only slowly converges to the maximum.


<<wscalcshift2, includ = , dependso = wshift_opt2", cach = >>=
large_scale <- make_match_surf(
  xs = seq(fro = 800, t = 200, length.ou = 1),
  ys = seq(fro = .98, t = .02, length.ou = 1)
)
@

<<wsshiftplot2, cach = , dependso = ("wscalcshift2",'wshift_opt2', "plotfunc"), fig.ca = distance matrix to reference measurement on shifted and compressed spectrum", dependso = wscalcshift2">>=
plot_match(large_scale)
@

<<wscalcshift2local, includ = , cach = >>=
medium_scale <- make_match_surf( xs = seq(fro = 700, t = 300, length.ou = 1),
                                 ys = seq(fro = .995, t = .005, length.ou = 1))
@

<<wsshiftplot2local, cach = , dependso = ("wscalcshift2local",'wshift_opt2', "plotfunc"), fig.ca = local distance matrix to reference measurement on shifted and compressed spectrum", dependso = wscalcshift2">>=
plot_match(medium_scale)
@

<<wscalcshift2locallocal, includ = , cach = >>=
small_scale <- make_match_surf(xs = seq(fro = 550, t = 450, length.ou = 1),
                               y = eq(fro = .999, t = .001, length.ou = 1))
@
<<wsshiftplot2locallocal, cach = , dependso = ("wscalcshift2locallocal",'wshift_opt2', "plotfunc"), fig.ca = direct environment around maximum of distance matrix to reference measurement on shifted and compressed spectrum", dependso = wscalcshift2">>=
plot_match(small_scale)
@


\subsubsection{Algorithm Candidate}

In order to achieve any fit careful optimization is necessary.  The
algorithms provided by \citet{JohNlopt} was used.  Two optimizations
were changed first a global gradient free method to estimate the general
location of the maximum and second a local method with constructed
gradient to quickly reach the maximum.

As global method the method \ac{DIRECT-L} is applied, as mentioned by
\citet{JohNlopt} for global search it is not advisable to have an
objective in terms of step size or change in value of objective
function, instead a fixed number of iterations (at the moment 100) is
set.  Local search is done using the \ac{BOBYQA} here the objective is
set by considering step size, as the data is provided in steps
optimizing for steps smaller than \num{1e-2} is not necessary.


<<wscalcshift1f, includ = , cach = >>=
vander <- function(xs, nmax)
  outer(xs, seq(fro = , t = max), function(x, i) x^i)

reference_spec <- ssb
tofit <- ssa
generated_w <- make_densewarp(tofit)

optim_generator <- function(reference_spec, generated_w, warp_fun){
  reference <- reference_spec/sqrt(sum(reference_spec^2))
  function(a){
    warped <- generated_w(warp_fun(a),
                          wher = eq_along(reference))
    nw <- sqrt(sum(warped^2))
    -sum(reference * warped)/nw
  }
}

make_polywarp <- function(n) function(a) function(x) vander(x, n) %*% a
ninit <- function(n, f0) c(f0, 1, rep(0, n-1))
warp0 <- function(a) function(x) a[[1]]+x


ni <- 2
ni_fit <- function(ni, pre){
  starta <- c(pre, ifelse(n = 1, 1, 0))
  ubs <- 10^ (10-7 * seq(ni+1))
  lbs <- -ubs
  lbs[2:(ni+1)]  <- 0
  tols <- ubs/1e5

  if (ni>0) {
    starta[[2]] <- 1
    ubs[[2]] <- 1+ubs[[2]]
    lbs[[2]] <- 1+lbs[[2]]
  }


  polywarp <- make_polywarp(ni)
  og_fin <- optim_generator(reference_spec, generated_w, polywarp)

  first_shift <- nloptr( x0 = starta,
                        eval_f = og_fin,
                        lb = lbs,
                        ub = ubs,
                        opts = list(algorith = NLOPT_GN_DIRECT_L",
                                    maxeval = 100)
                        )

  best_shift <- nloptr( x0 = first_shift$solution,
                       eval_f = og_fin,
                       lb = lbs,
                       ub = ubs,
                       opts = list(algorith = NLOPT_LN_BOBYQA",
                                   xtol_re = e-5)
                       )
}
@

<<calc_orders, includ = , cach = >>=
warp_orders <- local({
  pre <- 0
  warp_orders <- list()
  for (i in 1:5){
    nr <- ni_fit(i, pre)
    warp_orders <- c(warp_orders, list(nr))
    pre <- nr$solution
  }
  warp_orders
})
@

We see in \fref{fig:wsqualdim} that with increasing polynomial
order the cosine distance is initially not improved.  At higher orders
there are two problems: 1) numeric accuracy as powers like \num{4e5}
need to be taken to this power and 2) to guarantee the warp function is
monotonic.

<<wsqualdim, dependso = ('wscalcshift1f',"calc_orders"), cach = , fig.ca = improvent in distance by increasing warp polynomial.  Lower is a better match.">>=
local({
qs <- -sapply(warp_orders, function(x) x$objective)
lik <- qs/ (1-qs)
ll <- log(lik)

plot(seq_along(qs), log(1-qs), xla = poly order", yla = log cosine distance", typ = p")
})
@

<<, dependso = ("calc_orders")>>=
local({
pars <- lapply(warp_orders, function(x) x$solution)
})
@

<<, eva = , includ = >>=
res <- warp3(bestbest$par)
res(1)
res(length(ssa)) - length(ssa)

rv <- res(seq_along(ssa))
dif <- rv - seq_along(ssa)

max(dif)
min(dif)
which.min(dif)
which.max(dif)


startv <- c(est.shi$optim$bestmem, 1, 0, 0)
warp3 <- function(a) function(x) a[[1]]+ a[[2]]*x + a[[3]]*sqrt(x) + a[[4]]*x^1.5
og_fin <- optim_generator(ssa, generated_w, warp3)
og_fin2 <- function(...) -og_fin(...)
bestbest <- optim(startv, og_fin2)

res <- warp3(bestbest$par)
rv <- res(seq_along(ssa))
dif <- rv - seq_along(ssa)
plot(dif, typ = l")

res0 <- warp0(-500)

orig <- seq(2e4, 2e5)
rv0 <- res0(orig)
rv <- res(orig)
mv_orig <- mcfun$to_mass(orig)
mv_new <- mcfun$to_mass(rv)
mv_new0 <- mcfun$to_mass(rv0)
md <- mv_new-mv_orig
md0 <- mv_new0-mv_orig
plot(mv_orig, md, typ = l")
lines(mv_orig, md0, typ = l", co = green")

plot(mv_orig, mv_new-mv_new0, typ = l")
plot(mv_orig, (mv_new-mv_new0)/mv_orig, typ = l")
plot(mv_orig, ssa, typ = l")
@

<<, eva = , includ = >>=
warp_searcher <- function(ref, new, warper){
  generated_w <- make_densewarp(new)
  og <- optim_generator(ref, generated_w, warp0)
  est.shi <- DEoptim(og,
                     lowe = 3000,
                     upper = 3000,
                     contro = ist(VT = 0.7)
                     )

  startv <- c(est.shi$optim$bestmem, 1, 0)
  og_fin <- optim_generator(ref, generated_w, warper)

  for (i in 1:4){
    vs <- sapply(pars, function(x) x[i])
    xs <- seq_along(vs)+i-1
    plot(xs, vs)
  }
}
@
