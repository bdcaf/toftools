\section{Notes on warping between samples}

<<setup, include=F>>=
library("DEoptim")
library(baseline)
library(zoo)

source('R/tofReader.R')
source('R/tofSparse.R')

#tof.h5 <- 'testdata/2017.02.15-15h22m12s D6-EtOHbreathclemens.h5'
tofA.h5 <- 'testdata/2017.06.22-11h13m23s ca valve open.h5'
tofB.h5 <- 'testdata/2017.06.20-15h04m22s Aurelio valve off.h5'
tofA <- tofH5(tofA.h5)
tofB <- tofH5(tofB.h5)
sumSpecA <- (sumSpec.TofH5(tofA))/tofA$indexhelp$N
sumSpecB <- (sumSpec.TofH5(tofB))/tofB$indexhelp$N

mcfun <- recMassCal.TofH5(tofA)


plotComp <- function(refspec, otherspec = NULL, from, to, ylim=c(0,1e2)){
  plot(refspec, type='l', 
	   xlim=c(from, to),
	   ylim=ylim,
	   xlab='index',
	   ylab='cps'
	   )
  if (!is.null(otherspec)) lines(otherspec, type='l', col='red')
  massRange <- pretty(with(mcfun, c( toMass(from), toMass(to))),n=10)
  indRange <- with(mcfun, toIndex(massRange))
  bad <- indRange < from | indRange > to
  massRange <- massRange[!bad]
  indRange <- indRange[!bad]
  axis(3,indRange, labels=massRange,line=1,col="red",col.ticks="red",col.axis="red")
}

@

Immediate results hinted that in single measurements the drift is small.
To formulate the procedure warping between measurements was chosen.
Concretely the samples \texttt{\Sexpr{tofA.h5}} and
\texttt{\Sexpr{tofB.h5}} are selected and the sum spectra will be
examined. A subsection of the spectra are shown in figure \ref{fig:wssumspec}.

Sum spectra are different to the spectra of individual scans in the
sense that even in the range between molecular masses noise adds up to a
smooth signal.  To keep alignment simple the baseline is cleaned useing
the baseline package from \citet{Lil2015}.  A regional plot is shown in
figure \ref{fig:wsbaseline}. Most algorithm in this package work
sufficiently well.  Although the default \texttt{als} algorithm requires
construction of a matrix with dimension of lenght sample $\times$ lenght
sampl, which fails due to memory constraints as these spectra are
typical \num{400000} entries.

<<wssumspec, cache=T,fig.cap='Comparing the unprocessed sum spectra of two samples, the shift corresponds to about 0.5 amu at m/z 60'>>=
plotComp(sumSpecA, sumSpecB, from=11.5e4, to=13.5e4)
@

<<wsbaseline, fig.cap='baseline correction in sum spectrum.', cache=T>>=
sspec <- sumSpecA
refSpec <- baseline(matrix(sspec, nrow=1), 
					method= 'rollingBall', 
					wm=100, ws=100)@corrected[1,]
refSpec[refSpec<0.005]<-0

plotComp(sumSpecA, refSpec, from=12.0e4, to=13.0e4, ylim=c(0,2))
@

<<wssat, cache=T, depends=c('wsbaseline'), fig.cap='saturated peaks'>>=
par(mfrow=c(1,2)) 
plotComp(refSpec, from=7.99e4, to=8.02e4)
plotComp(refSpec, from=9.96e4, to=9.98e4)
@

<<,include = F>>=
prep_spec <- function(sspec, atof, wid=30){
  workspec <- baseline(matrix(sspec, nrow=1), method= 'rollingBall', wm=100, ws=100)@corrected[1,]
  workspec[workspec<0.001]<- 0
  log1p(workspec)
}
@

The aim is to find a warp that will adjust the position of peaks in the
sample spectrum to the one in the reference spectrum.  This often is
done by means of mass calibration.  Although in order for this to work
peaks of known mass need to be identified in the spectrum.  It is
generally not easy to find a sufficient number of peaks whose mass is
known and are present in sufficient quality.  Usually this is a manual
identification task which makes it hard to automate.  Typically these peaks are
directly related to precursor ions and of low mass - generally it is
hard to identify peaks at high masses.  In presented workflow we don't
identify peaks, but instead search for a warp that transforms the
spectrum best.

There are several warping functions available.  As TOF spectrometry has
a simple structure we find the parametric time warp most promising.  The
most common dynamic time warp is unsuitable, as we can not guarantee all
peaks to be present in each spectrum.
The resampling algorithm presented in \citet{Eilers2004a} is not
suitable for our approach as we need AUC of peaks maintained over the
transformation.   The problem is that presented algorithm only works
well if within every original bin there is a single new coordinate.
However starting with linear transformations this is no longer
guaranteed.  Fortunately there is a simple correction by instead
interpolating the cumulative sum and calculating differences over the
new values.

It is worth stressing that even if the parametric function describing
the reindexing is simple and differentiable the warping function is not.

The spectra are also dominated by large peaks.  In order to reduce their
influence the signal is \texttt{log1p} transformed. An exemplary
presentation is shown in figure \ref{fig:wscleansum}.

<<wscleansum, cache=T, fig.cap='peak log1p profile of two measurements'>>=
ssa <- prep_spec(sumSpecA)
ssb <- prep_spec(sumSpecB)
plotComp(ssa, ssb, from=12.0e4, to=13.0e4, ylim=c(0,4))
@

<<, include=F>>=
optim_generator <- function(orientSpec, wf){
  reference <- orientSpec/sqrt(sum(orientSpec^2))
  function(a, dense_spec){
	warp_fun <- wf(a)
	warped <- warp_dense( dense_spec, warp_fun)
	cor.full.full(warped, reference) 
  }
}

warp0 <- function(a) 
  function(x) a[[1]]+x # + a[[2]]*x # + a[[3]]*x^2

warp1 <- function(a) 
  function(x) a[[1]]+ a[[2]]*x # + a[[2]]*x # + a[[3]]*x^2

@

An exemplary warping based on shifting the spectrum is shown in figure
\ref{wsshiftplot}.  There is an optimal warping shifting the spectrum
around 500 indices to the left.  But it is also visible there are locale
maxima shifting spectra to other full masses.  This makes finding the
globaly best warping demanding.

<<wscalcshifts,include=F, cache=T>>=
og <- optim_generator(ssa, warp0)
og2 <- function(...) -og(...)
#og(1,ssb)
shifts <- seq(from=-3000, to=2000, length.out=99)
val <- sapply(shifts, function(x) og(x,ssb))

est.shi <- DEoptim(og2, 
				   lower=-3000,
				   upper = 3000,
				   dense_spec=ssb,
				   control=list(VTR=-0.9)
				   )

bestbest <- optim(est.shi$optim$bestmem, 
				  og2, 
				  gr=NULL, 
				  ssb,
				  lower=-3000, 
				  upper=3000,
				  method='Brent')
@

<<wsshiftplot, cache=T, fig.cap="distance to reference measurement on shifted spectrum", dependson="wscalcshifts">>=
plot(shifts,val, type='l', xlab='shift', ylab='agreement')
abline(v=bestbest$par)
text(x=bestbest$par, y=0.1, sprintf("%3.1f",bestbest$par), pos=4)
@

<<wscalcshift2,include=F, cache=T>>=
og <- optim_generator(ssa, warp1)
#og(1,ssb)
wif <- Vectorize(function(a,b) og(c(a,b),ssb))
xs <- seq(from=-1000, to=-200, length.out=17)
ys <- seq(from=0.6, to=1.4, length.out=21)
vals <- outer(xs, ys, FUN=wif )
@

<<wsshiftplot2, cache=T, fig.cap="distance matrix to reference measurement on shifted and compressed spectrum", dependson="wscalcshift2">>=
image(xs,ys,log(vals), xlab='shift', ylab='scale')
@



