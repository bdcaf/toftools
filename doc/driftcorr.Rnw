\subsection{Unwarping}

Unwarping a lengthy measurement is a complex task.  

A typical TOF spectrum is extremely sparse. From the typical 398999 bins
collected only less than 2500 contain numbers greater zero (obtained
  from a breath sample).

The currently most widely used warping correction --- the dynamic time
warp (dtw) performs in its original implementation under such conditions
rather poorly and is easily confused as the traces of individual peaks
are very similar.

Here we consider two variants:
\begin{itemize}
  \item the parametric time warp
  \item dynamic time warp enhanced by penalty for warping
\end{itemize}


As the spectrum is a large vector it is useful to transfer it into a
sparser coding.  We chose a kind of run-length encoding.

<<initialization>>=
source('R/spec_tools.R')
source('R/tofReader.R')
source('R/massCalTools.R')
library(dplyr)
@

<<>>=
# load the data
tof.h5 <- 'testdata/Ac just breath after C (2014-10-23T11h34m53_#).h5'
fid <-H5Fopen(tof.h5)
tofblock <- get.raw.tofblock(fid)
indexhelp <- tof.indexhelp(tofblock)
spec0 <- read.spec.ind(tofblock, indexhelp, 1)
spec1 <- read.spec.ind(tofblock, indexhelp, 700)
spec2 <- read.spec.ind(tofblock, indexhelp, 800)
spec3 <- read.spec.ind(tofblock, indexhelp, 900)
spec4 <- read.spec.ind(tofblock, indexhelp, 901)

inds <- seq_len(indexhelp$N) 
aspec <- function(n) read.spec.ind(tofblock, indexhelp, n)
#rf <- function(x,n) x + aspec(n)
#ss <- Reduce(rf, inds, 0, accumulate=F)
ss <- read.sum.spec(fid)

sss <- sparse_spec(spec0)
@

<<fig.cap="sum spectrum">>=
plot(ss, type='l')
@

<<>>=
m2 <- masscal_legacy_smooth(fid, indexhelp)

calib <- m2[1,]
spec <- aspec(1)
ma <- with(calib, (seq_along(spec)-b)^2/a^2)
plot(ma, spec, type='l')

masscal_c1 <- function(fid, indexhelp, 
					   resolution=1e4,
					   mass.low=10,
					   mass.high=200){
  mass_axis <- make_mass_axis(resolution=resolution, mass.low=mass.low, mass.high=mass.high)
}


<<fig.cap="original mass calibration jumps">>=
# mass calibration jumps
legacy_masscal <- read.mass.cals(fid)
par(mfrow=c(2,1))
plot(legacy_masscal[1,], type='l')
plot(legacy_masscal[2,], type='l')
@

<<fig.cap="some smoothing may globally be more effective">>=
# mass calibration a smooth one makes maybe sense
df <- as_data_frame(t(legacy_masscal)) %>% mutate(write = 1:nrow(.))
a_smooth <- with(df, smooth.spline(write, V1))
b_smooth <- with(df, smooth.spline(write, V2))

r <- with(indexhelp, 1/dims[[3]])
ci <- indexhelp$calc.indices %>% 
  mutate(x = write - 0.5 + r*buf,
  		 a = predict(a_smooth, x=x)$y,
  		 b = predict(b_smooth, x=x)$y
  		 )

par(mfrow=c(2,1))

plot(df$write, df$V1, type='p')
lines(ci$x, ci$a, col='red', lwd=3)

plot(df$write, df$V2, type='p')
lines(ci$x, ci$b, col='red', lwd=3)
@

## try comparing the results

<<>>=
peak_stat <- function(spec0, maxis){
  spec0[1]<-0
  mom0 = sum(spec0)
  mom1 = sum(spec0*maxis)
  mom2 = sum(spec0*maxis^2)
  mm = max(spec0)
  im <- which.max(spec0)
  ig = spec0 > (mm/2)
  tmp <- maxis[ig]
  fwhm <- tmp[length(tmp)]-tmp[1]

  list(mean = mom1/mom0,
	  var = mom2/mom0 - (mom1/mom0)^2,
	  fwhm = fwhm,
	  max.mass = maxis[im])
}

@
### m/z 31

#### only one mass calibration per measurement
<<>>=
base.mass <- 31
curr.mass.range <- 
  make_mass_axis( mass.low=base.mass-0.05, 
				  mass.high=base.mass + 0.05)

cal0 <- with(df, list(a=median(V1), b=median(V2)))
spec0 <- spec2mav(ss,cal0, curr.mass.range)

r0 <- peak_stat(spec0, curr.mass.range)
#plot(curr.mass.range, spec0, type='l')
@

<<fig.cap="Acetone with only one calibration for whole measurement">>=
plot(curr.mass.range, spec0, type='l')
@

#### Tof daq calibration

<<>>=
legacy_masscal <- read.mass.cals(fid)

ihc <- indexhelp$calc.indices %>% left_join(df, by='write')

n <- 100
n2spec <- function(ihc,n){
  sa <- aspec(n)
  cala <- with(ihc[n,], list( a=V1, b=V2))
  speca <- spec2mav(sa,cala, curr.mass.range)
}

rfun <- function(x, n){
  x + n2spec(ihc,n)
}

allSpec <- Reduce(rfun, seq_len(indexhelp$N), 0)

plot(curr.mass.range, allSpec, type='l')
#ra <- peak_stat(allSpec, curr.mass.range)
@


#### smooth tof daq

<<>>=
legacy_masscal <- read.mass.cals(fid)
df <- as_data_frame(t(legacy_masscal)) %>% mutate(write = 1:nrow(.))
a_smooth <- with(df, smooth.spline(write, V1))
b_smooth <- with(df, smooth.spline(write, V2))

r <- with(indexhelp, 1/dims[[3]])
ci <- indexhelp$calc.indices %>% 
  mutate(x = write - 0.5 + r*buf,
  		 a = predict(a_smooth, x=x)$y,
  		 b = predict(b_smooth, x=x)$y
  		 )

calfun <- function(n)
  ci[n,]

n2spec <- function(cf,n){
  sa <- aspec(n)
  cala <- cf(n)
  speca <- spec2mav(sa,cala, curr.mass.range)
}

rfun <- function(x, n){
  x + n2spec(calfun,n)
}

allSpecS <- Reduce(rfun, seq_len(indexhelp$N), 0)

plot(curr.mass.range, allSpecS, type='l')
rS <- peak_stat(allSpecS, curr.mass.range)
@


<<fig.cap="overlay tof daq calibrations">>=
plot(curr.mass.range, spec0, type='l')
lines(curr.mass.range, allSpec, col='red')
lines(curr.mass.range, allSpecS, col='blue')
@


## realigning

<<>>=
n<- 1000
cumspec <- read.sum.spec(fid)
sa <- aspec(n)
ca <- cumspec-sa

css <- cumsum(sa)
cca <- cumsum(ca)

inds <- seq_along(cca)
af <- approxfun(inds, css, rule=2)


scaled <- function(af,inds,d,e) {
  i2 <- inds/d-e
  c(0,diff(af(i2)))
}


dist_fun <- function(af, d, e){
  sas <- scaled(af,inds, d,e)
  1 - cor(sas,ca)
}

best_shift <-
  optim(c(1,0), 
	  function(x) dist_fun(af, x[[1]], x[[2]])
	  )

es <- seq(-0,0.7,length.out=50)
ed <- sapply(es, function(x) dist_fun(af,best_shift$par[[1]],x))

ds <- seq(1- 2e-5,1.00002,length.out=50)
dd <- sapply(ds, function(x) dist_fun(af,x,best_shift$par[[2]]))

par(mfrow=c(2,1))
plot(es,ed, type='l')
plot(ds,dd, type='l')

@


<<>>=
optim_shift <- function(n){
  curr.spec <- aspec(n)
  other.specs <- cumspec-curr.spec
  cum.cur.spec <- cumsum(curr.spec)
  
  work.indices <- seq_along(cumspec)
  inds <- seq_along(curr.spec)
  interp.spec <- approxfun(inds, cum.cur.spec, rule=2)
  shifted.spec <- function(x) {
  	e <- x[[1]]
  	d <- x[[2]]
    i2 <- inds/d-e
    c(0,diff(interp.spec(i2)))
  }

  dist2other <- function(x){
	sas <- shifted.spec(x)
	1 - cor(sas, other.specs)
  }

  spec.opt <- optim(c(0,1), dist2other) 
  return(spec.opt$par)
}

#a <- optim_shift(4)

#os <- lapply(seq_len(indexhelp$N), optim_shift)
os <- lapply(seq_len(20), optim_shift)

otl <- do.call(rbind, os)
@

### ptw seems all the rage
<<>>=
library(ptw)
n <- 100
  curr.spec <- matrix(aspec(n), nrow=1)
  other.specs <- matrix(cumspec, nrow=1) - curr.spec

system.time(
tmp <- ptw(other.specs, curr.spec, 
		   mode = "forward",
           warp.type = "global", 
           trwdth = 10)
)

s2 <- tmp$warped.sample
s2[is.na(s2)] <- 0
sum(curr.spec)
sum(s2, na.rm=T)

plot(x=inds, curr.spec, type='l')
lines(x=inds, t(tmp$warped.sample), col='red')

tmp$warp.coef
curr.spec2 <- matrix(aspec(101), nrow=1)
upd.spec <- other.specs - curr.spec2 + s2
system.time(
tmp2 <- ptw( upd.spec, curr.spec2, 
		   mode = "forward",
           warp.type = "global", 
           smooth.param = 0, 
           init.coef = tmp$warp.coef,
           trwdth = 10)
)

@

This isn't very fast either - and I'm unhappy that count rates are not
preserved.
